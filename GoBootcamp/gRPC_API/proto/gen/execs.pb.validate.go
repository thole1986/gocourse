// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: execs.proto

package grpcapipb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ForgotPasswordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForgotPasswordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgotPasswordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForgotPasswordResponseMultiError, or nil if none found.
func (m *ForgotPasswordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgotPasswordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Confirmation

	// no validation rules for Message

	if len(errors) > 0 {
		return ForgotPasswordResponseMultiError(errors)
	}

	return nil
}

// ForgotPasswordResponseMultiError is an error wrapping multiple validation
// errors returned by ForgotPasswordResponse.ValidateAll() if the designated
// constraints aren't met.
type ForgotPasswordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgotPasswordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgotPasswordResponseMultiError) AllErrors() []error { return m }

// ForgotPasswordResponseValidationError is the validation error returned by
// ForgotPasswordResponse.Validate if the designated constraints aren't met.
type ForgotPasswordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgotPasswordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgotPasswordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgotPasswordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgotPasswordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgotPasswordResponseValidationError) ErrorName() string {
	return "ForgotPasswordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ForgotPasswordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgotPasswordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgotPasswordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgotPasswordResponseValidationError{}

// Validate checks the field values on ForgotPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForgotPasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgotPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForgotPasswordRequestMultiError, or nil if none found.
func (m *ForgotPasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgotPasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Email

	if len(errors) > 0 {
		return ForgotPasswordRequestMultiError(errors)
	}

	return nil
}

// ForgotPasswordRequestMultiError is an error wrapping multiple validation
// errors returned by ForgotPasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type ForgotPasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgotPasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgotPasswordRequestMultiError) AllErrors() []error { return m }

// ForgotPasswordRequestValidationError is the validation error returned by
// ForgotPasswordRequest.Validate if the designated constraints aren't met.
type ForgotPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgotPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgotPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgotPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgotPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgotPasswordRequestValidationError) ErrorName() string {
	return "ForgotPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ForgotPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgotPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgotPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgotPasswordRequestValidationError{}

// Validate checks the field values on Confirmation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Confirmation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Confirmation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfirmationMultiError, or
// nil if none found.
func (m *Confirmation) ValidateAll() error {
	return m.validate(true)
}

func (m *Confirmation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Confirmation

	if len(errors) > 0 {
		return ConfirmationMultiError(errors)
	}

	return nil
}

// ConfirmationMultiError is an error wrapping multiple validation errors
// returned by Confirmation.ValidateAll() if the designated constraints aren't met.
type ConfirmationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfirmationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfirmationMultiError) AllErrors() []error { return m }

// ConfirmationValidationError is the validation error returned by
// Confirmation.Validate if the designated constraints aren't met.
type ConfirmationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfirmationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfirmationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfirmationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfirmationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfirmationValidationError) ErrorName() string { return "ConfirmationValidationError" }

// Error satisfies the builtin error interface
func (e ConfirmationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfirmation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfirmationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfirmationValidationError{}

// Validate checks the field values on ResetPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResetPasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResetPasswordRequestMultiError, or nil if none found.
func (m *ResetPasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetPasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResetCode

	// no validation rules for NewPassword

	// no validation rules for ConfirmPassword

	if len(errors) > 0 {
		return ResetPasswordRequestMultiError(errors)
	}

	return nil
}

// ResetPasswordRequestMultiError is an error wrapping multiple validation
// errors returned by ResetPasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type ResetPasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetPasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetPasswordRequestMultiError) AllErrors() []error { return m }

// ResetPasswordRequestValidationError is the validation error returned by
// ResetPasswordRequest.Validate if the designated constraints aren't met.
type ResetPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetPasswordRequestValidationError) ErrorName() string {
	return "ResetPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResetPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetPasswordRequestValidationError{}

// Validate checks the field values on UpdatePasswordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePasswordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePasswordResponseMultiError, or nil if none found.
func (m *UpdatePasswordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PasswordUpdated

	// no validation rules for Token

	if len(errors) > 0 {
		return UpdatePasswordResponseMultiError(errors)
	}

	return nil
}

// UpdatePasswordResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePasswordResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePasswordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordResponseMultiError) AllErrors() []error { return m }

// UpdatePasswordResponseValidationError is the validation error returned by
// UpdatePasswordResponse.Validate if the designated constraints aren't met.
type UpdatePasswordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordResponseValidationError) ErrorName() string {
	return "UpdatePasswordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordResponseValidationError{}

// Validate checks the field values on UpdatePasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePasswordRequestMultiError, or nil if none found.
func (m *UpdatePasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CurrentPassword

	// no validation rules for NewPassword

	if len(errors) > 0 {
		return UpdatePasswordRequestMultiError(errors)
	}

	return nil
}

// UpdatePasswordRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordRequestMultiError) AllErrors() []error { return m }

// UpdatePasswordRequestValidationError is the validation error returned by
// UpdatePasswordRequest.Validate if the designated constraints aren't met.
type UpdatePasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordRequestValidationError) ErrorName() string {
	return "UpdatePasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordRequestValidationError{}

// Validate checks the field values on ExecLogoutResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecLogoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecLogoutResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecLogoutResponseMultiError, or nil if none found.
func (m *ExecLogoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecLogoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LoggedOut

	if len(errors) > 0 {
		return ExecLogoutResponseMultiError(errors)
	}

	return nil
}

// ExecLogoutResponseMultiError is an error wrapping multiple validation errors
// returned by ExecLogoutResponse.ValidateAll() if the designated constraints
// aren't met.
type ExecLogoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecLogoutResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecLogoutResponseMultiError) AllErrors() []error { return m }

// ExecLogoutResponseValidationError is the validation error returned by
// ExecLogoutResponse.Validate if the designated constraints aren't met.
type ExecLogoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecLogoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecLogoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecLogoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecLogoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecLogoutResponseValidationError) ErrorName() string {
	return "ExecLogoutResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExecLogoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecLogoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecLogoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecLogoutResponseValidationError{}

// Validate checks the field values on EmptyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyRequestMultiError, or
// nil if none found.
func (m *EmptyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyRequestMultiError(errors)
	}

	return nil
}

// EmptyRequestMultiError is an error wrapping multiple validation errors
// returned by EmptyRequest.ValidateAll() if the designated constraints aren't met.
type EmptyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyRequestMultiError) AllErrors() []error { return m }

// EmptyRequestValidationError is the validation error returned by
// EmptyRequest.Validate if the designated constraints aren't met.
type EmptyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyRequestValidationError) ErrorName() string { return "EmptyRequestValidationError" }

// Error satisfies the builtin error interface
func (e EmptyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyRequestValidationError{}

// Validate checks the field values on ExecLoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExecLoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecLoginResponseMultiError, or nil if none found.
func (m *ExecLoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecLoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Token

	if len(errors) > 0 {
		return ExecLoginResponseMultiError(errors)
	}

	return nil
}

// ExecLoginResponseMultiError is an error wrapping multiple validation errors
// returned by ExecLoginResponse.ValidateAll() if the designated constraints
// aren't met.
type ExecLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecLoginResponseMultiError) AllErrors() []error { return m }

// ExecLoginResponseValidationError is the validation error returned by
// ExecLoginResponse.Validate if the designated constraints aren't met.
type ExecLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecLoginResponseValidationError) ErrorName() string {
	return "ExecLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExecLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecLoginResponseValidationError{}

// Validate checks the field values on ExecLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExecLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecLoginRequestMultiError, or nil if none found.
func (m *ExecLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUsername()) < 6 {
		err := ExecLoginRequestValidationError{
			field:  "Username",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ExecLoginRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := ExecLoginRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9@.#$+-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 9 {
		err := ExecLoginRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 9 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ExecLoginRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := ExecLoginRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9@.#$+-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExecLoginRequestMultiError(errors)
	}

	return nil
}

// ExecLoginRequestMultiError is an error wrapping multiple validation errors
// returned by ExecLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type ExecLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecLoginRequestMultiError) AllErrors() []error { return m }

// ExecLoginRequestValidationError is the validation error returned by
// ExecLoginRequest.Validate if the designated constraints aren't met.
type ExecLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecLoginRequestValidationError) ErrorName() string { return "ExecLoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExecLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecLoginRequestValidationError{}

var _ExecLoginRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z0-9@.#$+-]+$")

var _ExecLoginRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z0-9@.#$+-]+$")

// Validate checks the field values on DeleteExecsConfirmation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteExecsConfirmation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteExecsConfirmation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteExecsConfirmationMultiError, or nil if none found.
func (m *DeleteExecsConfirmation) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteExecsConfirmation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return DeleteExecsConfirmationMultiError(errors)
	}

	return nil
}

// DeleteExecsConfirmationMultiError is an error wrapping multiple validation
// errors returned by DeleteExecsConfirmation.ValidateAll() if the designated
// constraints aren't met.
type DeleteExecsConfirmationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteExecsConfirmationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteExecsConfirmationMultiError) AllErrors() []error { return m }

// DeleteExecsConfirmationValidationError is the validation error returned by
// DeleteExecsConfirmation.Validate if the designated constraints aren't met.
type DeleteExecsConfirmationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteExecsConfirmationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteExecsConfirmationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteExecsConfirmationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteExecsConfirmationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteExecsConfirmationValidationError) ErrorName() string {
	return "DeleteExecsConfirmationValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteExecsConfirmationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteExecsConfirmation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteExecsConfirmationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteExecsConfirmationValidationError{}

// Validate checks the field values on ExecIds with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecIds) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecIds with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExecIdsMultiError, or nil if none found.
func (m *ExecIds) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecIds) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExecIdsMultiError(errors)
	}

	return nil
}

// ExecIdsMultiError is an error wrapping multiple validation errors returned
// by ExecIds.ValidateAll() if the designated constraints aren't met.
type ExecIdsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecIdsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecIdsMultiError) AllErrors() []error { return m }

// ExecIdsValidationError is the validation error returned by ExecIds.Validate
// if the designated constraints aren't met.
type ExecIdsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecIdsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecIdsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecIdsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecIdsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecIdsValidationError) ErrorName() string { return "ExecIdsValidationError" }

// Error satisfies the builtin error interface
func (e ExecIdsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecIds.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecIdsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecIdsValidationError{}

// Validate checks the field values on GetExecsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetExecsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExecsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExecsRequestMultiError, or nil if none found.
func (m *GetExecsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExecsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetExecsRequestValidationError{
					field:  "Exec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetExecsRequestValidationError{
					field:  "Exec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetExecsRequestValidationError{
				field:  "Exec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSortBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetExecsRequestValidationError{
						field:  fmt.Sprintf("SortBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetExecsRequestValidationError{
						field:  fmt.Sprintf("SortBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetExecsRequestValidationError{
					field:  fmt.Sprintf("SortBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetExecsRequestMultiError(errors)
	}

	return nil
}

// GetExecsRequestMultiError is an error wrapping multiple validation errors
// returned by GetExecsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetExecsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExecsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExecsRequestMultiError) AllErrors() []error { return m }

// GetExecsRequestValidationError is the validation error returned by
// GetExecsRequest.Validate if the designated constraints aren't met.
type GetExecsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExecsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExecsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExecsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExecsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExecsRequestValidationError) ErrorName() string { return "GetExecsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetExecsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExecsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExecsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExecsRequestValidationError{}

// Validate checks the field values on Exec with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Exec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Exec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExecMultiError, or nil if none found.
func (m *Exec) ValidateAll() error {
	return m.validate(true)
}

func (m *Exec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if utf8.RuneCountInString(m.GetFirstName()) < 1 {
		err := ExecValidationError{
			field:  "FirstName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Exec_FirstName_Pattern.MatchString(m.GetFirstName()) {
		err := ExecValidationError{
			field:  "FirstName",
			reason: "value does not match regex pattern \"^[a-zA-Z ]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetLastName()) < 1 {
		err := ExecValidationError{
			field:  "LastName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Exec_LastName_Pattern.MatchString(m.GetLastName()) {
		err := ExecValidationError{
			field:  "LastName",
			reason: "value does not match regex pattern \"^[a-zA-Z ]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = ExecValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUsername()) < 6 {
		err := ExecValidationError{
			field:  "Username",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Exec_Username_Pattern.MatchString(m.GetUsername()) {
		err := ExecValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9@.#$+-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 9 {
		err := ExecValidationError{
			field:  "Password",
			reason: "value length must be at least 9 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Exec_Password_Pattern.MatchString(m.GetPassword()) {
		err := ExecValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9@.#$+-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PasswordChangedAt

	// no validation rules for UserCreatedAt

	// no validation rules for PasswordResetToken

	// no validation rules for PasswordTokenExpires

	// no validation rules for Role

	// no validation rules for InactiveStatus

	if len(errors) > 0 {
		return ExecMultiError(errors)
	}

	return nil
}

func (m *Exec) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Exec) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// ExecMultiError is an error wrapping multiple validation errors returned by
// Exec.ValidateAll() if the designated constraints aren't met.
type ExecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecMultiError) AllErrors() []error { return m }

// ExecValidationError is the validation error returned by Exec.Validate if the
// designated constraints aren't met.
type ExecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecValidationError) ErrorName() string { return "ExecValidationError" }

// Error satisfies the builtin error interface
func (e ExecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecValidationError{}

var _Exec_FirstName_Pattern = regexp.MustCompile("^[a-zA-Z ]+$")

var _Exec_LastName_Pattern = regexp.MustCompile("^[a-zA-Z ]+$")

var _Exec_Username_Pattern = regexp.MustCompile("^[a-zA-Z0-9@.#$+-]+$")

var _Exec_Password_Pattern = regexp.MustCompile("^[a-zA-Z0-9@.#$+-]+$")

// Validate checks the field values on Execs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Execs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Execs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExecsMultiError, or nil if none found.
func (m *Execs) ValidateAll() error {
	return m.validate(true)
}

func (m *Execs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecsValidationError{
						field:  fmt.Sprintf("Execs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecsValidationError{
						field:  fmt.Sprintf("Execs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecsValidationError{
					field:  fmt.Sprintf("Execs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecsMultiError(errors)
	}

	return nil
}

// ExecsMultiError is an error wrapping multiple validation errors returned by
// Execs.ValidateAll() if the designated constraints aren't met.
type ExecsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecsMultiError) AllErrors() []error { return m }

// ExecsValidationError is the validation error returned by Execs.Validate if
// the designated constraints aren't met.
type ExecsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecsValidationError) ErrorName() string { return "ExecsValidationError" }

// Error satisfies the builtin error interface
func (e ExecsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecsValidationError{}
